# 多线程

>[!NOTE]1. 什么是多线程  
>
>线程 (Thread) 是操作系统能调度的最小执行单位，一个进程可以包含多个线程。  
>
>在 Python 里，默认运行的代码就是主线程，你可以再开启多个子线程，和主线程并发执行。  

>[!NOTE]2. Python（CPython 实现）有 全局解释器锁 GIL，它保证同一时间只有一个线程在执行 Python 字节码。  
>
>所以多线程 不能真正利用多核 CPU 来做计算密集型任务（比如大规模数学计算）。  
>
>但是在 I/O 密集型任务（网络请求、文件读写）中，多线程仍然能大幅提升效率，因为等待 I/O 时，线程会让出 GIL。  

>[!NOTE]3. 常见应用场景  
>
>✅ 适合：  
>
>- 网络爬虫（同时请求多个网页）
>
>- 文件下载/上传
>
>- Socket 服务端处理多个客户端
>
>- GUI 程序保持界面响应（主线程负责 UI，子线程负责耗时任务）
>
>❌ 不适合：  
>
>- 大规模数值计算（推荐用 多进程 multiprocessing 或者 NumPy/Cython 等绕过 GI  

>[!NOTE]4. 线程锁（避免冲突）  
>
>多个线程可能会同时修改共享数据，导致数据不一致 → 需要用锁 threading.Lock。


>多线程 (threading)
>
>- 多线程在 I/O 密集型任务 中 → 并发效果很好
>
>- 但在 CPU 密集型任务 中 → 不能并行，只能并发
>
>多进程 (multiprocessing)
>
>- 每个进程有独立的 Python 解释器 + GIL
>
>- 可以在多核 CPU 上真正做到 并行计算
>
>- 适合 CPU 密集型任务（大规模计算、图像处理等）


>并发 (Concurrency)
>
>- 多个任务在同一时间段内交替执行。
>
>- 它不一定是“真正同时”，可能是任务切换得很快，看起来像同时在跑。
>
>- 类比：一个人同时和多人聊天，其实是快速在不同对话窗口之间切换。
>
>并行 (Parallelism)
>
>- 多个任务在同一时刻真正同时执行。
>
>- 必须依赖多核 CPU 或多台机器。
>
>- 类比：多个人分别和不同人聊天，确实是同时进行。  

📝 Python 多线程 vs 多进程 对比表

| 特性            | 多线程 (threading) 🧵                                  | 多进程 (multiprocessing) 🔥                                   |
| ------------------- | --------------------------------------------------- | ---------------------------------------------------------- |
| **运行机制**      | 一个进程里开启多个线程，共享同一块内存空间                               | 开启多个进程，每个进程有独立的内存和 Python 解释器                              |
| **并发 / 并行能力** | 受 GIL 限制 → 只能并发，不能真正利用多核 CPU                        | 每个进程有独立 GIL，可以真正并行利用多核 CPU                                 |
| **适用场景**      | I/O 密集型任务（网络请求、文件 I/O、数据库）                          | CPU 密集型任务（计算、加密、图像处理）                                      |
| **内存消耗**      | 较低（线程共享内存）                                          | 较高（进程独立内存空间）                                               |
| **数据共享**      | 简单（共享全局变量、数据结构）                                     | 复杂（需要 Queue、Pipe、Manager 等 IPC 机制）                         |
| **启动速度**      | 快（轻量级，线程上下文切换开销小）                                   | 慢（进程启动和上下文切换开销大）                                           |
| **安全性**       | 容易出现线程安全问题（需要 Lock 保护共享数据）                          | 进程间数据隔离，天然更安全                                              |
| **调试难度**      | 相对容易                                                | 较难，特别是跨进程调试                                                |
| **跨平台支持**     | 全平台支持                                               | Windows 上开销更大（进程复制机制不同于 Linux）                             |
| **典型库**       | `threading`、`concurrent.futures.ThreadPoolExecutor` | `multiprocessing`、`concurrent.futures.ProcessPoolExecutor` |


## threading库  

- 来源：Python 标准库（自带，不需安装）。

- 功能：用于创建和管理多线程程序，比底层 _thread 提供更高层次的接口。

- 适用场景：I/O 密集型任务（网络请求、文件读写、日志处理等）。

- 限制：受 GIL（全局解释器锁） 影响，Python 同一时间只有一个线程能执行字节码，因此 CPU 密集型任务用 multiprocessing 更合适。


<br>

### 基础用法  

```py
import threading

def worker(num):
    print(f"线程 {num} 正在运行")

t = threading.Thread(target=worker, args=(1,))
t.start()
t.join()  # 等待线程结束
```

常用属性和方法  

- start()：启动线程

- join(timeout=None)：等待线程结束

- is_alive()：判断线程是否存活

- name：线程名字，可读写

- ident：线程 ID

- daemon：设置是否为守护线程（主线程退出时，守护线程会被杀掉）