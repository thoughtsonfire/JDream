# re 库

## re 库简介

`re` 是 `Python` 内置的正则表达式库，用于 字符串匹配、搜索、替换、分割 等操作。
正则表达式（Regular Expression）是一种 模式匹配语法，可以高效地处理复杂的字符串操作。

- 和容器、参数列表有关的索引 → 从 0 开始（list、tuple、format 参数）。

- 和正则分组有关的编号 → 0 保留给整体匹配，捕获组从 1 开始。

## 常用函数

`re` 提供了几个常用的 `API`：

| 函数                            | 说明                                                               |
| ------------------------------- | ------------------------------------------------------------------ |
| `re.match(pattern, string)`     | **从头开始匹配**字符串，匹配成功返回 `Match` 对象，否则返回 `None` |
| `re.search(pattern, string)`    | **搜索整个字符串**，找到第一个匹配项返回 `Match` 对象              |
| `re.findall(pattern, string)`   | 返回所有匹配结果的 **列表**                                        |
| `re.finditer(pattern, string)`  | 返回一个迭代器，里面是所有的 `Match` 对象                          |
| `re.split(pattern, string)`     | 按照匹配的内容分割字符串，返回列表                                 |
| `re.sub(pattern, repl, string)` | 替换匹配的内容，可以传字符串或函数                                 |

```py
import re

text = "我的电话是: 123-4567, 你的呢？"

# match：只匹配开头
print(re.match(r"\d+", text))   # None

# search：匹配第一个出现的
print(re.search(r"\d+", text).group())  # 123

# findall：匹配所有的
print(re.findall(r"\d+", text))  # ['123', '4567']

# sub：替换
print(re.sub(r"\d+", "X", text))  # 我的电话是: X-X, 你的呢？

# split：分割
print(re.split(r"\D+", text))  # ['', '123', '4567', '']
```

## 常见模式符号

正则表达式的核心是 模式（`pattern`），一些常见的符号：

| 符号     | 含义                                        |         |                 |
| -------- | ------------------------------------------- | ------- | --------------- |
| `.`      | 匹配任意字符（除了换行）                    |         |                 |
| `^`      | 匹配字符串开头                              |         |                 |
| `$`      | 匹配字符串结尾                              |         |                 |
| `*`      | 匹配前一个字符 **0 次或多次**               |         |                 |
| `+`      | 匹配前一个字符 **1 次或多次**               |         |                 |
| `?`      | 匹配前一个字符 **0 次或 1 次**              |         |                 |
| `{m,n}`  | 匹配前一个字符 **m 到 n 次**                |         |                 |
| `[]`     | 匹配字符集合，比如 `[abc]` 匹配 `a`/`b`/`c` |         |                 |
| `[^...]` | 匹配不在集合里的字符                        |         |                 |
| `\d`     | 匹配数字 `[0-9]`                            |         |                 |
| `\w`     | 匹配字母、数字、下划线                      |         |                 |
| `\s`     | 匹配空白字符（空格、制表符、换行等）        |         |                 |
| \`       | \`                                          | 或，\`a | b`匹配`a`或`b\` |
| `()`     | 分组，提取子串，或者配合 \`                 | \` 使用 |                 |

## 编译优化`compile`

对于重复使用的正则，可以先编译：

```py
pattern = re.compile(r"\d+")
print(pattern.findall("今天是2025年9月4日"))  # ['2025', '9', '4']
```

## 捕获组

### `re.match` / `re.search`

这两个返回的都是 Match 对象（如果匹配成功）。
至于你拿到的内容，取决于你调用的方法：

- .group(0) → 整个匹配结果

- .group(1)、.group(2)… → 第 n 个捕获组

- .groups() → 返回所有捕获组组成的元组

```py
import re

s = "abc123xyz"

m = re.search(r"(\d+)([a-z]+)", s)
print(m.group(0))  # '123xyz'  → 整体匹配
print(m.group(1))  # '123'     → 第1组
print(m.group(2))  # 'xyz'     → 第2组
print(m.groups())  # ('123', 'xyz')
```

### re.findall

- 无分组 → 返回完整匹配列表

- 一个分组 → 返回该分组匹配内容的列表

- 多个分组 → 返回元组列表，每个元组里是各个分组内容

::: code-group

```py [无分组]
re.findall(r"\d+", "abc123xyz456")
# ['123', '456']
```

```py [一个分组]
re.findall(r"(\d+)", "abc123xyz456")
# ['123', '456']
```

```py [多个分组]
re.findall(r"(\d+)-(\d+)", "2025-09 123-456")
# [('2025', '09'), ('123', '456')]
```

:::

### re.finditer

返回的是 迭代器，元素是 Match 对象。

所以规则和 `match/search` 一样，你取 `.group()` 才决定是整个还是某个分组：

```py
for m in re.finditer(r"(\d+)([a-z]+)", "123abc456def"):
    print(m.group(0), m.groups())
# 输出：
# 123abc ('123', 'abc')
# 456def ('456', 'def')
```

### re.sub

替换的时候，捕获组也有影响：

- 可以在 `repl` 中用 `\1`, `\2`... 引用分组

- 或者 `repl` 写成函数，函数的参数是 `Match` 对象，就能用 `.group(n)`

```py
s = "2025-09-04"

# 用分组引用
print(re.sub(r"(\d{4})-(\d{2})-(\d{2})", r"\2/\3/\1", s))
# '09/04/2025'

# 用函数
def repl(m):
    return f"{m.group(2)}/{m.group(3)}/{m.group(1)}"

print(re.sub(r"(\d{4})-(\d{2})-(\d{2})", repl, s))
# '09/04/2025'
```

### re.split

分割时，如果正则里有分组，分隔符也会保留在结果里。

```py
re.split(r"[,;]", "a,b;c")
# ['a', 'b', 'c']

re.split(r"([,;])", "a,b;c")
# ['a', ',', 'b', ';', 'c']
```

## 总结表

| API                | 捕获组影响                                          |
| ------------------ | --------------------------------------------------- |
| `match` / `search` | 返回 `Match` 对象 → `.group()` 决定取整体还是分组   |
| `findall`          | 直接影响返回值：0 组=整体，1 组=列表，n 组=元组列表 |
| `finditer`         | 返回 `Match` 对象迭代器 → 用 `.group()` 决定        |
| `sub`              | `\1, \2` 或函数里 `.group(n)` 来替换                |
| `split`            | 分组会让分隔符也出现在结果中                        |

- `group(0)` = 完整匹配结果

- `group(n)` = 第 `n` 个分组内容

- `groups()` = 所有分组（不含 `0`）

## 修饰符

| 修饰符 | 描述                                                 |
| ------ | ---------------------------------------------------- |
| re.I   | 使用匹配对大小写不敏感                               |
| re.L   | 使用本地化识别（loacal-aware）匹配                   |
| re.M   | 多行匹配，影响^和$                                   |
| re.S   | 匹配包括换行在内的所有字符                           |
| re.U   | 根据 Unicode 字符集解析。这个标志影响\w、\W、\b 和\B |
| re.X   | 该标志通过给予你更灵活的格式以便将正则写的更易于理解 |
